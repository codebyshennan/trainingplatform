<link
  href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/css/bootstrap.min.css"
  rel="stylesheet"
  integrity="sha384-KyZXEAg3QhqLMpG8r+8fhAXLRk2vvoC2f3B09zVXn8CA5QIVfZOJ3BCsw2P0p/We"
  crossorigin="anonymous"
/>

<script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script
  src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"
  integrity="sha384-U1DAWAznBHeqEIlVSCgzq+c9gqGAJn5c/t99JyeKa9xxaYpSvHU5awsuZVVFIhvj"
  crossorigin="anonymous"
></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.0.1/chart.min.js"></script>
    <script src="static/chartjs-dragdata.js"></script>
<!-- 
<script src="https://unpkg.com/packery@2/dist/packery.pkgd.js"></script>
<script src="https://unpkg.com/draggabilly@2/dist/draggabilly.pkgd.js"></script>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous"> -->

<!-- Entire bundle -->
<!-- <script src="https://cdn.jsdelivr.net/npm/@shopify/draggable@1.0.0-beta.11/lib/draggable.bundle.js"></script> -->
<!-- 

<script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script> -->

<style>
* { box-sizing: border-box; } 

body { font-family: sans-serif; }

/* ---- grid ---- */

.grid {
  background: #DDD;
  max-width: 1200px;
  height:100px;
}

/* clear fix */
.grid:after {
  content: '';
  display: block;
  clear: both;
}

/* ---- .grid-item ---- */

.grid-item {
  float: left;
  width: 100px;
  height: 100px;
  background: #C09;
  border: 2px solid hsla(0, 0%, 0%, 0.5);
}

.grid-item--width2 { width: 200px; }
.grid-item--height2 { height: 50px; }

.grid-item:hover {
  border-color: hsla(0, 0%, 100%, 0.5);
  cursor: move;
}

.grid-item.is-dragging,
.grid-item.is-positioning-post-drag {
  background: #C90;
  z-index: 2;
}

.packery-drop-placeholder {
  outline: 3px dashed hsla(0, 0%, 0%, 0.5);
  outline-offset: -6px;
  -webkit-transition: -webkit-transform 0.2s;
          transition: transform 0.2s;
}
</style>

<!-- main div -->
<div class="container-fluid">
  <div class="row">FRIDAY 3 Sep</div>
  <!-- overview -->
  <div class="row">
    <div class="col">
      <div class="row">
        <div class="col-10">Untitled Workout
          <i class="fas fa-dumbbell"></i>
          <i class="fas fa-running"></i>
          <i class="fas fa-swimmer"></i>
          <i class="fas fa-biking"></i>

        </div>
        <div class="col-2">upload | summary</div>
      </div>
    </div>
    <div class="col">
      <div class="row">
        <div class="col-4">Click or drag blocks</div>
        <div class="col-8">Units</div>
      </div>
    </div>
  </div>

  <!-- packery -->
  <div class="row">
    <div class="col-1" style="font-size: 0.5rem" id='one'>
      <p>100</p>
      <br>
      <br>
      <p>50</p>
      <br><br>
      <p>0</p>
    </div>
    <div class="col-11">
      <canvas id="myChart" width="200" height="100"></canvas>

<!--       
      <div class="grid">
        <div class="grid-item grid-item--width2"></div>
        <div class="grid-item grid-item--height1"></div>
        <div class="grid-item grid-item--height1"></div>
        <div class="grid-item"></div>
          <div class="grid-item grid-item--height1"></div>
      </div>
      <div class="row xaxis">
        1 2 3 4 5 6 7 8 9 10
      </div> -->
    </div>
    <!-- <div class="col-4"><div class="draggable" id='three'> Draggable Element </div></div> -->
  </div>

<!-- <p><button class="append-button">Append items</button></p> -->



  <div class=""></div>

  <!-- main -->
  <div class="row">
    <!-- planned/completed -->
    <div class="col-6">
      <form action="" method="">
      <div class="row">
        
          <div class="col-6">
            <div class="form">
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
            </div>
            <div class="">
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
              <p>Duration <input type="text" size="15" /><input type="text" size="15" />h:m:s</p>
            </div>
          </div>
          <div class="col-6">
            <div class="">
              <label for="fname">Description</label>
              <input type="textarea" id="fname" name="fname" size="50"></div>
            <div class="">How did you feel
              <i class="far fa-grin-hearts"></i>
              <i class="far fa-grin"></i>
              <i class="far fa-sad-cry"></i>
              <i class="far fa-sad-tear"></i>
              <i class="far fa-sad-cry"></i>


            </div>
            <div class="">Perceived Exertion</div>
            <div class="">Post Activity Comments</div>
          </div>
        </form>
      </div>
    </div>
    <div class="col-6">workout details editor</div>
  </div>
</div>
<!-- InteractJS -->
<!-- <script>
const position = { x: 0, y: 0 }

interact('.dragparent')
.draggable({
      startAxis: 'x',
    lockAxis: 'x',
})
.dropzone({
    ondrop: (event)=>{
      console.log('event >> ', event)
      console.log(event.relatedTarget.id + ' was dropped into ' + event.target.id)
    },
  })
  .on('dropactivate', function (event) {
    event.target.classList.add('drop-activated')
  })


interact('.draggable')
  .draggable({
    // inertia: true,
    modifiers: [
      
      // The restriction value specifies the area that the action will be confined to. 
      // interact.modifiers.restrict({
      //   restriction: 'parent',
      //   endOnly: true
      // // }),
      // interact.modifiers.snap({
      //   targets: [ { x: 300, y: 300 } ],
        // relativePoints: [
        //   { x: 0  , y: 0   },   // snap relative to the element's top-left,
        //   // { x: 0.5, y: 0.5 },   // to the center
        //   // { x: 1  , y: 1   }    // and to the bottom-right
        // ]
      // })
    ],
    // startAxis: 'x',
    // lockAxis: 'x',
    listeners: {
      start (event) {
        console.log(event.type, event.target)
      },
      move (event) {
        position.x += event.dx
        position.y += event.dy

        event.target.style.transform =
          `translate(${position.x}px, ${position.y}px)`
      },
    }
  })
  .resizable({
    modifiers: [
      //restrictEdges lets you specify inner and outer dimensions that the target element must have when resizing. You can think of inner as setting the minimum size of the element and outer as the maximum size.
      interact.modifiers.restrictEdges({
        inner: {
          left: 100,  // the left edge must be <= 100
          right: 200  // the right edge must be >= 200
        },
        outer: {
          left: 0,    // the left edge must be >= 0
          right: 300  // the right edge must be <= 300
        }
      }),
    interact.modifiers.snapSize({
      targets: [
        { width: 100 },
        interact.snappers.grid({ width: 100, height: 100 }),
      ],
    }),
  ],
    cursorChecker (action, interactable, element, interacting) {
      // the library uses biderectional arrows <-> by default,
      // but we want specific arrows (<- or ->) for each diriection
      if (action.edges.left) { return 'w-resize' }
      if (action.edges.right) { return 'e-resize' }
    },
    edges: { top: true, left: true, bottom: false, right: true },
    listeners: {
      move: function (event) {
        let { x, y } = event.target.dataset

        x = (parseFloat(x) || 0) + event.deltaRect.left
        y = (parseFloat(y) || 0) + event.deltaRect.top

        Object.assign(event.target.style, {
          width: `${event.rect.width}px`,
          height: `${event.rect.height}px`,
          transform: `translate(${x}px, ${y}px)`
        })

        Object.assign(event.target.dataset, { x, y })
      }
    }
  })
  .on('dropactivate', function (event) {
    event.target.classList.add('drop-activated')
  })
// lock the drag to the starting direction
// interact('.draggable').draggable({
//   startAxis: 'xy',
//   lockAxis: 'start'
// });

</script> -->

<!-- PackeryJS -->
<!-- <script>
  let pckry = new Packery('.grid', {
    itemSelector: '.grid-item',
    columnWidth: 100,
    resize: false,
    // // percentPosition: true,
    horizontal: true,
    originTop: false,
    initLayout: false
  });

  pckry.getItemElements().forEach( ( itemElem ) => {
    const draggie = new Draggabilly( itemElem, {
      axis: 'x',
      containment: '.grid'
    } );
    pckry.bindDraggabillyEvents( draggie );
  });

  pckry.layout();
    // pckry.shiftLayout();

  function onLayout() {
    pckry.layout();
    // pckry.shiftLayout();
    console.log('layout done');
  }
  // bind event listener
  pckry.on( 'dragItemPositioned', onLayout );

  // show item order after layout
  function orderItems() {
    pckry.getItemElements().forEach( function( itemElem, i ) {
      itemElem.textContent = i + 1;
    });
  }

  pckry.on( 'layoutComplete', orderItems );
  pckry.on( 'dragItemPositioned', orderItems );

  var grid = document.querySelector('.grid')
  var appendButton = document.querySelector('.append-button');

appendButton.addEventListener( 'click', function() {
  // create new item elements
  var items = [
    getItemElement(),
    getItemElement(),
    getItemElement()
  ];
  // append elements to container
  var fragment = document.createDocumentFragment();
  fragment.appendChild( items[0] );
  fragment.appendChild( items[1] );
  fragment.appendChild( items[2] );
  grid.appendChild( fragment );

pckry = new Packery('.grid', {
    itemSelector: '.grid-item',
    columnWidth: 100,
    resize: false,
    // // percentPosition: true,
    horizontal: true,
    originTop: false,
    initLayout: false
  });

  pckry.getItemElements().forEach( ( itemElem ) => {
    const draggie = new Draggabilly( itemElem, {
      axis: 'x',
      containment: '.grid'
    } );
    pckry.bindDraggabillyEvents( draggie );
  });

  pckry.layout();
});

// make <div class="grid-item grid-item--width# grid-item--height#" />
function getItemElement() {
  var item = document.createElement('div');
  // add width and height class
  var wRand = Math.random();
  var hRand = Math.random();
  var widthClass = wRand > 0.85 ? 'grid-item--width3' : wRand > 0.7 ? 'grid-item--width2' : '';
  var heightClass = hRand > 0.85 ? 'grid-item--height3' : hRand > 0.5 ? 'grid-item--height2' : '';
  item.className = 'grid-item ' + widthClass + ' ' + heightClass;
  return item;
}


</script> -->

<!-- ChartJS -->
<script>
  // to insert data
  // inject into myLineChart.data <- array
var ctx = $("#myChart");

const data = [
  {
    x: 1617253200000,
    y: 10
  },
  {
    x: 1617256800000,
    y: 50
  },
  {
    x: 1617260400000,
    y: 30
  },
    {
    x: 1617260400000,
    y: 30
  }
];

const config = {
  responsive: true,
  plugins:{
      tooltip: {
        callbacks: {
          title: function(context) {
            const timeString = new Date(context[0].parsed.x).toLocaleTimeString(navigator.language, {
              hour: '2-digit',
              minute:'2-digit'
            })
  
            return timeString
          }
        }
      },
      dragData: {        
          round: 0,
          dragX: false,
          showTooltip: true,
          onDragStart:function (e, datasetIndex, index, value) {
          },
          onDrag: function (e, datasetIndex, index, value) {
              e.target.style.cursor = 'grabbing'
              //console.log("Drag Value: ", value.x)
          },
          onDragEnd: function (e, datasetIndex, index, value) {
              e.target.style.cursor = 'default'
          },
      },
    },
    scales: {
        x:{
          type: 'linear',
          min: 1617253000000,
          max: 1617260800000,
          ticks: {
            callback(v) {
              return new Date(v).toLocaleTimeString(navigator.language, {
                hour: '2-digit',
                minute:'2-digit'
              })
            }
          }
        },
        y:{
           beginAtZero: true,
                steps: 1,
                stepValue: 1,
                max: 100
          },
      }
};

var myLineChart = new Chart(ctx, {
    type: 'line',
    data: {
      datasets: [
        {data:data,
        fill:true,
        stepped:true}
      ]
    },
    options: config
});

</script>